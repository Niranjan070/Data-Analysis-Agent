"""
Safe Code Executor
==================
Executes Python/Pandas code generated by the EDA agent in a controlled
environment. Captures outputs, errors, and generated charts.
"""

import sys
import io
import os
import traceback
import uuid
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns
from typing import Dict, Any, Optional


CHARTS_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "static", "charts")
os.makedirs(CHARTS_DIR, exist_ok=True)


class CodeExecutor:
    """Safely executes data analysis code and captures results."""

    def __init__(self):
        self.execution_count = 0
        self.allowed_modules = {
            'pandas', 'numpy', 'matplotlib', 'seaborn',
            'scipy', 'math', 'statistics', 'collections',
            'datetime', 'json', 're',
        }

    def execute(self, code: str, df: pd.DataFrame, 
                df_name: str = "df") -> Dict[str, Any]:
        """
        Execute Python code with the DataFrame available in scope.
        
        Args:
            code: Python code string to execute
            df: The DataFrame to analyze
            df_name: Variable name for the DataFrame in execution scope
            
        Returns:
            Dict with stdout, result, charts, errors
        """
        self.execution_count += 1

        # Set up execution environment
        chart_id = str(uuid.uuid4())[:8]
        chart_path = None

        # Capture stdout
        old_stdout = sys.stdout
        sys.stdout = captured_output = io.StringIO()

        # Create execution namespace
        exec_globals = {
            '__builtins__': __builtins__,
            'pd': pd,
            'np': np,
            'plt': plt,
            'sns': sns,
            df_name: df.copy(),  # Work on a copy
            'df': df.copy(),
        }

        # Add scipy if available
        try:
            from scipy import stats as scipy_stats
            exec_globals['scipy_stats'] = scipy_stats
        except ImportError:
            pass

        result = {
            "success": False,
            "stdout": "",
            "result_value": None,
            "chart_path": None,
            "error": None,
            "execution_id": self.execution_count,
        }

        try:
            # Close any existing plots
            plt.close('all')

            # Execute the code
            exec(code, exec_globals)

            # Check if a plot was created
            if plt.get_fignums():
                chart_filename = f"chart_{chart_id}.png"
                chart_full_path = os.path.join(CHARTS_DIR, chart_filename)
                plt.savefig(chart_full_path, dpi=100, bbox_inches='tight',
                           facecolor='#1a1a2e', edgecolor='none')
                plt.close('all')
                chart_path = f"/static/charts/{chart_filename}"
                result["chart_path"] = chart_path

            # Get stdout
            result["stdout"] = captured_output.getvalue()

            # Try to get the last expression value
            # (useful for things like df.describe())
            try:
                last_line = code.strip().split('\n')[-1].strip()
                if (not last_line.startswith(('import', 'from', '#', 'plt.', 'sns.', 
                                               'print', 'for ', 'if ', 'while ', 'def ',
                                               'class ', 'with ', 'try'))
                    and '=' not in last_line.split('#')[0]):
                    val = eval(last_line, exec_globals)
                    if val is not None:
                        if isinstance(val, pd.DataFrame):
                            result["result_value"] = val.to_string(max_rows=20, max_cols=10)
                        elif isinstance(val, pd.Series):
                            result["result_value"] = val.to_string()
                        else:
                            result["result_value"] = str(val)
            except:
                pass

            result["success"] = True

        except Exception as e:
            result["error"] = f"{type(e).__name__}: {str(e)}"
            result["traceback"] = traceback.format_exc()

        finally:
            sys.stdout = old_stdout
            plt.close('all')

        return result

    def get_result_summary(self, result: Dict[str, Any], max_length: int = 300) -> str:
        """Create a compressed summary of execution results for history."""
        parts = []

        if result["success"]:
            if result.get("stdout"):
                stdout = result["stdout"][:max_length]
                parts.append(f"Output: {stdout}")
            if result.get("result_value"):
                val = result["result_value"][:max_length]
                parts.append(f"Value: {val}")
            if result.get("chart_path"):
                parts.append("Chart generated âœ“")
        else:
            parts.append(f"Error: {result.get('error', 'Unknown')}")

        return " | ".join(parts) if parts else "Executed (no output)"
